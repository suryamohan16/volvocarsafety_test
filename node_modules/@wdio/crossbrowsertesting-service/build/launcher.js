"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const perf_hooks_1 = require("perf_hooks");
const cbt_tunnels_1 = __importDefault(require("cbt_tunnels"));
const logger_1 = __importDefault(require("@wdio/logger"));
const log = logger_1.default('@wdio/crossbrowsertesting-service');
class CrossBrowserTestingLauncher {
    constructor(_options, _caps, _config) {
        this._options = _options;
        this._caps = _caps;
        this._config = _config;
        this._isUsingTunnel = false;
        this._cbtTunnelOpts = Object.assign({
            username: this._config.user,
            authkey: this._config.key,
            nokill: true
        }, this._options.cbtTunnelOpts);
    }
    async onPrepare() {
        if (!this._options.cbtTunnel) {
            return;
        }
        /**
         * measure TestingBot tunnel boot time
         */
        const obs = new perf_hooks_1.PerformanceObserver((list) => {
            const entry = list.getEntries()[0];
            log.info(`CrossBrowserTesting tunnel successfully started after ${entry.duration}ms`);
        });
        obs.observe({ entryTypes: ['measure'], buffered: false });
        perf_hooks_1.performance.mark('tbTunnelStart');
        await util_1.promisify(cbt_tunnels_1.default.start)(this._cbtTunnelOpts);
        this._isUsingTunnel = true;
        perf_hooks_1.performance.mark('tbTunnelEnd');
        perf_hooks_1.performance.measure('bootTime', 'tbTunnelStart', 'tbTunnelEnd');
    }
    onComplete() {
        if (!this._isUsingTunnel) {
            return;
        }
        return new Promise((resolve, reject) => cbt_tunnels_1.default.stop((err) => {
            if (err) {
                return reject(err);
            }
            return resolve('stopped');
        }));
    }
}
exports.default = CrossBrowserTestingLauncher;
